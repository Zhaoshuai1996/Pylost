# coding=utf-8
'''
Created on Nov 6, 2017

Modified Mar 21,2018

Class to convert the *.has files generated by SHARPeR instrument to *.h5 files. A measurement has the following files
1. Raw patches from different scans  (n scans x m subapertures)
2. Header metadata

@author: ADAPA
'''
import datetime
import os

import h5py
from numpy import nan, unicode
import six

import numpy as np
from PyLOSt.data_in.sharper.ImopHasoSlopes import ImopHasoSlopes


class HasToH5():
    filePath = ''
    otype = 'a'
    entryName = ''

    # Data common to all scans in one measurement
    def __init__(self, outFilePath, otype='a', mName='MeasurementEntry', isNewData=False):
        """
        Initialize measurement entry and add metadata

        :param outFilePath: Output h5 file path
        :param otype: H5 file open types: default 'a'-read/write/create access
        :param mName: Measurement entry name
        :param isNewData: True if the current entry is created for the first time or to be overwritten
        :return:
        """
        self.filePath = outFilePath
        self.otype = otype
        self.entryName = mName
        self.h5f = h5py.File(outFilePath, otype)
        if otype == 'a' and isNewData:  # need to change for overwriting
            # Save attributes of file
            self.h5f.attrs[u'version'] = u'1'
            self.h5f.attrs[u'file_name'] = outFilePath
            if 'created_on' not in self.h5f.attrs:
                self.h5f.attrs[u'created_on'] = str(datetime.datetime.now())
            self.h5f.attrs[u'modified_on'] = str(datetime.datetime.now())
            self.h5f.attrs[u'creator'] = u'has_to_h5.py'
            self.h5f.attrs[u'HDF5_Version'] = six.u(h5py.version.hdf5_version)
            self.h5f.attrs[u'h5py_version'] = six.u(h5py.version.version)

            # Data entry
            if self.entryName in self.h5f:
                del self.h5f[self.entryName]
            self.entry = self.h5f.create_group(self.entryName)
            self.entry.attrs[u'NX_class'] = u'NXentry'
            self.entry.attrs[u'scan_type'] = u'line(1D)'
            self.entry.attrs[u'primary_axis'] = u'X'
            self.entry.attrs[u'secondary_axis'] = u''
            self.entry.attrs[u'flag_ref_subtracted'] = False
            self.entry.attrs[u'flag_gravity_corrected'] = False
            self.entry.attrs[u'flag_piston_corrected'] = False
            self.dataScans = self.entry.create_group('Data')
            self.dataScans.attrs[u'NX_class'] = u'NXdata'

            # meta data e.g. instrument, sample etc...
            self.metaData()
        self.h5f.close()

    @staticmethod
    def finish():
        ##TODO
        print('')

    # Load *.has patches in different scans
    def hasToH5(self, in_folder, fname, patch_count, h5scan, dircn, scanNo):
        """
        Function calls *.has reader (util.ImopHasoSlopes) and saves the data to h5 measurement entry

        :param in_folder: Raw data folder
        :param fname: File name prefix
        :param patch_count: Number of subapertures
        :param h5scan: Scan_xx group name
        :param dircn: Forward or backward
        :param scanNo: Current scan number
        :return:
        """
        try:
            self.h5f = h5py.File(self.filePath, self.otype)
            self.entry = self.h5f[self.entryName]
            self.entry.attrs['raw_data_loc'] = in_folder
            self.dataScans = self.entry['Data']
            slx_patches = []
            sly_patches = []
            mask_patches = []
            intensity_patches = []
            mx_patches = []
            my_patches = []
            mz_patches = []
            mRx_patches = []
            mRy_patches = []
            mRz_patches = []
            datetime_patches = []
            for j in (range(0, patch_count) if dircn != 'B' else range(patch_count - 1, -1, -1)):
                fin_path = os.path.join(in_folder, fname + '_index_' + str(j) + '.has')
                has_m = ImopHasoSlopes('Wrap', readXML=True, fname=fin_path)
                slx_patches.append(has_m.slopes_x)
                sly_patches.append(has_m.slopes_y)
                mask_patches.append(has_m.pupil_data)
                intensity_patches.append(has_m.intensity)
                # motor positions
                mx_patches.append(has_m.motorX if has_m.motorX else nan)
                my_patches.append(has_m.motorY if has_m.motorY else nan)
                mz_patches.append(has_m.motorTz if has_m.motorTz else nan)
                mRx_patches.append(has_m.motorRx if has_m.motorRx else nan)
                mRy_patches.append(has_m.motorRy if has_m.motorRy else nan)
                mRz_patches.append(has_m.motorRz if has_m.motorRz else nan)

                datetime_patches.append(has_m.time_stamp if has_m.time_stamp else u'')

            data_shape = np.array(slx_patches).shape
            # slopes in mrad        
            data = self.dataScans.create_group(h5scan)
            data.attrs[u'NX_class'] = u'NXdata'
            data.attrs[u'signal'] = u'slopes_x'
            data.attrs[u'axes'] = np.array([u'.', u'.', u'.'], dtype=h5py.special_dtype(vlen=unicode))
            data.attrs[u'name'] = h5scan
            data.attrs[u'scan_number'] = scanNo
            data.attrs[u'scan_direction'] = dircn
            data.attrs[u'pupil_data_dimensions'] = has_m.dimensions
            data.attrs[u'data_dimensions'] = data_shape
            data.attrs[u'data_dimensions_format'] = u'[patch count (length), width microlenses, length microlenses]'
            data.attrs[u'data_step'] = [has_m.steps.Y / 1000, has_m.steps.X / 1000]
            data.attrs[u'data_step_units'] = u'mm'
            # data.attrs[u'temperature']                  = [] # temp array

            data.create_dataset('slopes_x', shape=data_shape, dtype='float32', chunks=True)
            data.create_dataset('slopes_y', shape=data_shape, dtype='float32', chunks=True)
            data.create_dataset('intensity', shape=data_shape, dtype='int32', chunks=True)
            data.create_dataset('mask', shape=data_shape, dtype='bool_', chunks=True)
            data['slopes_x'][...] = slx_patches
            data['slopes_x'].attrs[u'units'] = u'mrad'
            data['slopes_x'].attrs[u'scale'] = u'1'
            data['slopes_y'][...] = sly_patches
            data['slopes_y'].attrs[u'units'] = u'mrad'
            data['slopes_y'].attrs[u'scale'] = u'1'
            data['mask'][...] = mask_patches
            data['intensity'][...] = intensity_patches

            # motor positions in mm or deg
            data['motor_X'] = mx_patches
            data['motor_X'].attrs[u'units'] = u'mm'
            data['motor_Y'] = my_patches
            data['motor_Y'].attrs[u'units'] = u'mm'
            data['motor_Z'] = mz_patches
            data['motor_Z'].attrs[u'units'] = u'mm'
            data['motor_RX'] = mRx_patches
            data['motor_RX'].attrs[u'units'] = u'deg'
            data['motor_RY'] = mRy_patches
            data['motor_RY'].attrs[u'units'] = u'deg'
            data['motor_RZ'] = mRz_patches
            data['motor_RZ'].attrs[u'units'] = u'deg'

            data['timestamps'] = np.string_(datetime_patches)
            data['timestamps'].attrs[u'format'] = u'YYYY-MM-DD HH:mm:ss'

            if 'Data/Ref1' in self.entry:
                data['ref'] = self.entry[
                    'Data/Ref1']  # softlink not working:: h5py.SoftLink(self.entryName+'/Data/Ref1')

        except Exception as e:
            print('hasToH5 <- HasToH5')
            print(e)
        finally:
            self.h5f.close()

        if scanNo == 1:
            self.updateMetaData(data)  # update only once

    def addRefEachScan(self, floc):
        """
        Add a seperate reference for each scan

        :param floc: Reference files (*.has) location
        :return:
        """
        self.h5f = h5py.File(self.filePath, self.otype)
        self.entry = self.h5f[self.entryName]
        h5scans = self.entry['Data']
        for i in h5scans.keys():
            if 'NX_class' in h5scans[i].attrs and h5scans[i].attrs['NX_class'] == 'NXdata':  # loop over scans
                sno = h5scans[i].attrs['scan_number']
                dir = h5scans[i].attrs['scan_direction']
                dir_str = 'forward' if dir == 'F' else 'backward'
                f = floc + '/ref_' + dir_str + '_' + str(sno) + '.has'
                self.addReference(f, loc=h5scans[i].name + '/ref')
        self.h5f.close()

    def addReference(self, f, loc='Data/Ref1'):
        """
        Add reference to measurement entry

        :param f: Reference file path (has format)
        :param loc: Relative location of reference under measurement entry
        :return:
        """
        self.h5f = h5py.File(self.filePath, self.otype)
        self.entry = self.h5f[self.entryName]
        if loc in self.h5f:
            del self.h5f[loc]
        #         __, hasObj                              = Imop_HasoSlopes_NewFromHasFile(f)# Load haso ref
        has_m = ImopHasoSlopes('Wrap', readXML=True, fname=f)

        ref = self.entry.create_group(loc)
        ref.attrs[u'timestamp'] = u''
        ref.attrs[u'rawfile_loc'] = f
        ref['slopes_x'] = has_m.slopes_x
        ref['slopes_x'].attrs[u'units'] = u'mrad'
        ref['slopes_x'].attrs[u'scale'] = u'1'
        ref['slopes_y'] = has_m.slopes_y
        ref['slopes_y'].attrs[u'units'] = u'mrad'
        ref['slopes_y'].attrs[u'scale'] = u'1'
        ref['mask'] = has_m.pupil_data
        ref['intensity'] = has_m.intensity
        self.h5f.close()

    def updateScanRef(self, utype='all', refLoc='Data/Ref1', scanStart=0, scanEnd=0):
        """
        Reference is linked to scans (either all scans or between start/end scans)

        :param utype: if utype is 'all', reference is linked to all scans
        :param refLoc: Relative path to reference under measurement entry
        :param scanStart: Start scan number. It is used if utype is not 'all'
        :param scanEnd: End scan number. It is used if utype is not 'all'
        :return:
        """
        self.h5f = h5py.File(self.filePath, self.otype)
        self.entry = self.h5f[self.entryName]
        h5scans = self.entry['Data']
        for i in h5scans.keys():
            if 'NX_class' in h5scans[i].attrs and h5scans[i].attrs['NX_class'] == 'NXdata':  # loop over scans
                if utype == 'all':
                    self.createRefLink(h5scans[i], refLoc)
                else:
                    if h5scans[i].attrs['scan_number'] >= scanStart and h5scans[i].attrs['scan_number'] <= scanEnd:
                        self.createRefLink(h5scans[i], refLoc)
        self.h5f.close()

    def createRefLink(self, h5si, refLoc):
        """
        Create hard link to reference data

        :param h5si: Scan_xx group
        :param refLoc: Reference location
        :return:
        """
        self.h5f = h5py.File(self.filePath, self.otype)
        self.entry = self.h5f[self.entryName]
        if 'ref' in h5si:
            del h5si['ref']
        h5si['ref'] = self.entry[refLoc]  # softlink not working:: h5py.SoftLink(refLoc)
        self.h5f.close()

    def updateMetaData(self, data=None, cntArr=None, instr_id=None, instr_location=None):
        """
        Update meta data

        :param data: Data group in h5
        :param cntArr: Scan/subaperture count array
        :param instr_id: Instrument id
        :param instr_location: Instrument physical location
        :return:
        """
        self.h5f = h5py.File(self.filePath, self.otype)
        self.entry = self.h5f[self.entryName]
        if instr_id:
            self.entry['Instrument'].attrs[u'instr_id'] = instr_id
        if instr_location:
            self.entry['Instrument'].attrs[u'instr_location'] = instr_location
        if data:
            self.entry['Instrument/resolution'][...] = data.attrs[u'data_step']
            self.entry['Instrument/pupil_data_dimensions'][...] = data.attrs[u'pupil_data_dimensions']
        if cntArr:
            self.entry['Measurement/scan_count'][...] = cntArr[1:4]
            self.entry['Measurement/subaperture_count'][...] = cntArr[0]
        self.h5f.close()

    def metaData(self, cntArr=None):
        """
        Meta data such as measurement conditions, sample details etc...

        :param cntArr: Scan/subaperture count array
        :return:
        """
        h5instr = self.entry.create_group('Instrument')
        h5instr.attrs[u'NX_class'] = u'NXinstrument'
        h5instr.attrs[u'wavelength'] = u'405 nm'
        h5instr.attrs[u'conditions'] = 'hood off, no cooling fans for optics, with enclosure'
        h5instr['name'] = 'SHARPeR @ ESRF'
        h5instr['version'] = 'v1.0.1'
        h5instr['pupil_dimensions'] = [13.2, 18.0]  # mm
        h5instr['pupil_dimensions'].attrs[u'units'] = u'mm'
        h5instr['pupil_dimensions'].attrs[u'format'] = u'Y, X'
        h5instr['pupil_data_dimensions'] = [11, 15]  # no of microlenses
        h5instr['pupil_data_dimensions'].attrs[u'units'] = u'# of microlenses'
        h5instr['resolution'] = [1.199297, 1.198329]  # mm
        h5instr['resolution'].attrs[u'units'] = u'mm'
        h5instr['resolution'].attrs[u'format'] = u'Y, X'
        h5instr['scale_factor'] = -0.5 * 1e3  # urad
        h5instr['scale_factor'].attrs[u'units'] = u'urad'

        mask = np.full((11, 15), True)
        mask[5, 7] = False
        h5instr['mask'] = mask

        h5msr = self.entry.create_group('Measurement')
        h5msr.attrs[u'NX_class'] = u'NXmeasurement'
        #         h5msr['orientation']                              = 'VFM'
        #         h5msr['orientation'].attrs[u'X']                  = u'Stitch axis'
        #         h5msr['orientation'].attrs[u'Y']                  = u'Tool axis'
        #         h5msr['orientation'].attrs[u'Z']                  = u'Optical axis'
        #         h5msr['orientation'].attrs[u'RX']                 = u'Y-tilt'
        #         h5msr['orientation'].attrs[u'RY']                 = u'X-tilt'
        #         h5msr['orientation'].attrs[u'RZ']                 = u'Rotation'

        h5msr['scan_count'] = cntArr[1:4] if cntArr is not None else [0, 0, 0]
        h5msr['scan_count'].attrs[u'format'] = u'[FW scans, BW scans, Static scans]'
        h5msr['subaperture_count'] = cntArr[0] if cntArr is not None else 0
        h5msr['temperature'] = []
        h5msr['type'] = 'AB scan, FB, normal incidence'

        aln_center = h5msr.create_group("Alignment")
        aln_center.attrs[u'name'] = 'Q-Sys LTP & RTT axes (at the center of mirror - default)'
        aln_center.attrs[u'units'] = u'X/Y/Tz - mm, Rx/Ry/Rz - deg'
        aln_center['X'] = 0
        aln_center['Y'] = 0
        aln_center['TZ'] = 0
        aln_center['RX'] = 0
        aln_center['RY'] = 0
        aln_center['RZ'] = 0
        aln_center['motionSpeed'] = [25]
        aln_center['motionSpeed'].attrs[u'units'] = u'mm/s'
        aln_center['motionSpeed'].attrs[u'axes'] = u'[X]'
        aln_center['mir_length'] = 0
        aln_center['mir_length'].attrs[u'units'] = u'mm'
        aln_center['mir_width'] = 0
        aln_center['mir_width'].attrs[u'units'] = u'mm'
        aln_center['residual_tiltX'] = 0
        aln_center['residual_tiltX'].attrs[u'units'] = u'mrad'
        aln_center['residual_tiltY'] = 0
        aln_center['residual_tiltY'].attrs[u'units'] = u'mrad'
        aln_center['residual_curv'] = 0
        aln_center['residual_curv'].attrs[u'units'] = u'm-1'
        aln_center['exposure_time'] = 0
        aln_center['exposure_time'].attrs[u'units'] = u'ms'
        aln_center['laser_level'] = 0
        aln_center['laser_level'].attrs[u'units'] = u'%'
        aln_center['acquisition_intensity'] = 0
        aln_center['acquisition_intensity'].attrs[u'units'] = u'%'

        aln_ref_center = h5msr.create_group("Alignment_ref")
        aln_ref_center.attrs[u'name'] = 'reference file'
        aln_ref_center.attrs[u'filename'] = 'data_ref_step1.h5'
        aln_ref_center.attrs[u'units'] = u'X/Y/Tz - mm, Rx/Ry/Rz - deg'
        aln_ref_center['X'] = 0
        aln_ref_center['Y'] = 0
        aln_ref_center['TZ'] = 0
        aln_ref_center['RX'] = 0
        aln_ref_center['RY'] = 0
        aln_ref_center['exposure_time'] = 0
        aln_ref_center['exposure_time'].attrs[u'units'] = u'ms'
        aln_ref_center['laser_level'] = 0
        aln_ref_center['laser_level'].attrs[u'units'] = u'%'

        h5sample = self.entry.create_group('Sample')
        h5sample.attrs[u'NX_class'] = u'NXsample'
        h5sample['name'] = ''
        h5sample['no_of_regions'] = 1
        h5sample['shape'] = 'plane'  # for multiple regions, an array sequence
        h5sample['material'] = 'uncoated'
        h5sample['material_bulk'] = 'Si'
        h5sample['total_dimensions'] = []
        h5sample['total_dimensions'].attrs[u'units'] = u'mm'
        h5sample['total_dimensions'].attrs[u'format'] = u'[length, width, height]'
        h5sample['regions_of_interest'] = []
        h5sample['regions_of_interest'].attrs[u'units'] = u'mm'
        h5sample['regions_of_interest'].attrs[u'format'] = u'[[X1,X2,Y1,Y2],...]'
        h5sample['orientation'] = 'up/side/down'
        h5sample['comments'] = '\n mirror placed on cyl rods at pos X=-L/4 & X=L/4 from center, no bender'
        h5sample['Params'] = 'Rc/p-q-theta/Major-minor'
        h5sample['Params'].attrs[u'units'] = u'm/m-m-mrad/m-m'

        # h5users                                             = self.h5f['Users'] if 'Users' in self.h5f else self.h5f.create_group('Users')
        # h5users.attrs[u'NX_class']                          = u'NXuser'
        # if 'Mercury' not in h5users:
        #     h5u                                                 = h5users.create_group('Mercury')
        #     h5u.attrs[u'NX_class']                              = u'NXuser'
        #     h5u['full_name']                                    = 'Mercury'
        #     h5u['email']                                        = ''
        #     h5u['location']                                     = ''
        #
        # self.entry['User']                                  = h5users['Mercury']

        h5u = self.entry.create_group('User')
        h5u.attrs[u'NX_class'] = u'NXuser'
        h5u['full_name'] = 'user_name'
        h5u['email'] = ''
        h5u['location'] = ''
