# coding=utf-8
'''
Created Mar 21,2018

Class to convert the *.slp2 files generated by ESRF LTP instrument to *.h5 files. A measurement has the following files
1. Raw patches from different scans  (n scans x m subapertures)
2. Header metadata

@author: ADAPA
'''
import datetime
import os

import h5py
import six

import numpy as np
from PyLOSt.data_in.ltp.read_slp import readSlp2File
from PyLOSt.data_in.util_data import joinFileNameSequence


class Slp2ToH5():
    filePath = ''
    otype = 'a'
    entryName = ''
    updMeta = True

    # Data common to all scans in one measurement
    def __init__(self, outFilePath, otype='a', mName='MeasurementEntry', isNewData=False):
        """
        Initialize measurement entry and add metadata

        :param outFilePath: Output h5 file path
        :param otype: H5 file open types: default 'a'-read/write/create access
        :param mName: Measurement entry name
        :param isNewData: True if the current entry is created for the first time or to be overwritten
        :return:
        """
        self.filePath = outFilePath
        self.otype = otype
        self.entryName = mName
        self.h5f = h5py.File(outFilePath, otype)
        if otype == 'a' and isNewData:  # overwriting
            # Save attributes of file
            self.h5f.attrs[u'default'] = u'Data/height'
            self.h5f.attrs[u'version'] = u'1'
            self.h5f.attrs[u'file_name'] = outFilePath
            self.h5f.attrs[u'created_on'] = str(datetime.datetime.now())
            self.h5f.attrs[u'instrument'] = u'Zygo Fizeau'
            self.h5f.attrs[u'creator'] = u'dat_to_h5.py'
            self.h5f.attrs[u'HDF5_Version'] = six.u(h5py.version.hdf5_version)
            self.h5f.attrs[u'h5py_version'] = six.u(h5py.version.version)

            # Data entry
            self.entry = self.h5f.create_group(self.entryName)
            self.entry.attrs[u'NX_class'] = u'NXentry'
            self.entry.attrs[u'scan_type'] = u'line(1D)'
            self.entry.attrs[u'primary_axis'] = u'X'
            self.entry.attrs[u'secondary_axis'] = u''
            self.entry.attrs[u'flag_ref_subtracted'] = False
            self.entry.attrs[u'flag_gravity_corrected'] = False
            self.entry.attrs[u'flag_piston_corrected'] = False
            self.dataScans = self.entry.create_group('Data')
            self.dataScans.attrs[u'NX_class'] = u'NXdata'

            # meta data e.g. instrument, sample etc...
            self.metaData()
        self.h5f.close()

    @staticmethod
    def finish():
        ##TODO
        print('')

    # Load *.has patches in different scans
    def slpToH5(self, in_folder, prefix, nbPatches, h5scan, dircn, scanNo, scanIdx=1, nbSelScans=1, patches_selected=[],
                options=['', '', 'slp2', []], progress_bar=None):
        """
        Function calls *.slp2 reader (readSlp2Data.readSlp2File) and saves the data to h5 measurement entry

        :param in_folder: Raw data folder
        :param prefix: File name prefix
        :param nbPatches: Number of subapertures
        :param h5scan: Scan_xx group name
        :param dircn: Forward or backward
        :param scanNo: Current scan number
        :return:
        """
        try:
            self.h5f = h5py.File(self.filePath, self.otype)
            self.entry = self.h5f[self.entryName]
            self.dataScans = self.entry['Data']
            slx = []
            mx = []
            fname = prefix
            pidx = 0
            if not np.any(patches_selected):
                patches_selected = list(range(1, nbPatches + 1)) if nbPatches > 0 else [1]
            for j in patches_selected:
                pidx = pidx + 1
                if progress_bar:
                    progress_bar.setValue(80 * (pidx / len(patches_selected)) * (scanIdx / nbSelScans))
                if nbPatches > 0:  # it has subapertures
                    fname = joinFileNameSequence(prefix, str(scanNo).zfill(2), str(j).zfill(2), options)
                else:
                    fname = joinFileNameSequence(prefix, str(scanNo).zfill(2), '', options)

                fin_path = os.path.join(in_folder, fname)
                if os.path.isfile(fin_path):
                    d = readSlp2File(fin_path)
                    ds = np.asarray(d['Slopes_Xmin'])
                    if nbPatches == 0:
                        slx = ds[np.newaxis, :, 1]
                        mx = ds[np.newaxis, :, 0]
                    else:
                        if not np.any(slx):
                            slx = ds[np.newaxis, :, 1]
                            mx = ds[np.newaxis, :, 0]
                        #     slx             = np.full((nbPatches,1,ds.shape[0]), np.nan, dtype='float')
                        #     mx              = np.full((nbPatches,1,ds.shape[0]), np.nan, dtype='float')
                        else:
                            if ds.shape[0] > slx.shape[-1]:
                                slx = np.pad(slx, [(0, 0), (0, 0), (0, ds.shape[0] - slx.shape[-1])], 'constant',
                                             constant_values=(np.nan, np.nan))
                                mx = np.pad(mx, [(0, 0), (0, 0), (0, ds.shape[0] - slx.shape[-1])], 'constant',
                                            constant_values=(np.nan, np.nan))
                                slx = np.append(slx, ds[np.newaxis, :, 1], axis=0)
                                mx = np.append(mx, ds[np.newaxis, :, 0], axis=0)
                            #     slx[j-1,:,:]      = ds[np.newaxis,:,1]
                            #     mx[j-1,:,:]       = ds[np.newaxis,:,0]
                            elif ds.shape[0] < slx.shape[-1]:
                                ds2s = np.pad(ds[np.newaxis, :, 1], [(0, 0), (0, slx.shape[-1] - ds.shape[0])],
                                              'constant', constant_values=(np.nan, np.nan))
                                ds2x = np.pad(ds[np.newaxis, :, 0], [(0, 0), (0, slx.shape[-1] - ds.shape[0])],
                                              'constant', constant_values=(np.nan, np.nan))
                                slx = np.append(slx, ds2s, axis=0)
                                mx = np.append(mx, ds2x, axis=0)

            # slopes in mrad       
            if np.any(slx):
                data_shape = np.array(slx).shape
                data = self.dataScans.create_group(h5scan)
                data.attrs[u'NX_class'] = u'NXdata'
                data.attrs[u'signal'] = u'slopes_x'
                data.attrs[u'name'] = h5scan
                data.attrs[u'scan_number'] = scanNo
                data.attrs[u'scan_direction'] = dircn
                data.attrs[u'data_dimensions'] = data_shape
                if slx.ndim == 2:
                    data.attrs[u'data_dimensions_format'] = u'[1 x length pixels]'
                    # data.attrs[u'axes']                     = np.array([u'.',u'motor_X'], dtype=h5py.special_dtype(vlen=unicode))
                elif slx.ndim == 3:
                    data.attrs[u'data_dimensions_format'] = u'[subapertures x 1 x length pixels] -- stitching ltp'
                    # data.attrs[u'axes']                     = np.array([u'.',u'.',u'motor_X'], dtype=h5py.special_dtype(vlen=unicode))
                data.attrs[u'data_step'] = float(d['step'])
                data.attrs[u'data_step_units'] = u'mm'
                data.attrs[u'temperature'] = d['temperature']  # temp array here or in NXmeasruement?
                data.attrs[u'temperature_timestamp'] = d['snapshot_time']

                data.create_dataset('slopes_x', shape=data_shape, dtype='float32', chunks=True)
                data['slopes_x'][...] = slx
                data['slopes_x'].attrs[u'units'] = u'urad'
                data['slopes_x'].attrs[u'scale'] = u'1'
                if progress_bar:
                    progress_bar.setValue(90 * (scanIdx / nbSelScans))

                # motor positions in mm or deg
                data['motor_X'] = np.array(mx).astype(np.float)
                data['motor_X'].attrs[u'units'] = u'mm'
                data['motor_Y'] = d['Axis 2: TRANSLATION']
                data['motor_Y'].attrs[u'units'] = u'mm'
                data['motor_Ry'] = []
                data['motor_Ry'].attrs[u'units'] = u'deg'
                data['timestamps'] = d['date_time']
                data['timestamps'].attrs[u'description'] = u'time when one FWD or BWD scan ended'

                if self.updMeta:
                    if d['reference'] == "ref substracted":
                        self.entry.attrs[u'flag_ref_subtracted'] = True
                    if d['gravity'] == "gravity correction":
                        self.entry.attrs[u'flag_gravity_corrected'] = True
                    self.updateMetaData(data, rawData=d)  # update only once
                    self.updMeta = False
            if progress_bar:
                progress_bar.setValue(100 * (scanIdx / nbSelScans))
            self.h5f.close()
        except Exception as e:
            print('slpToH5 <- Slp2ToH5')
            print(e)

    def updateMetaData(self, data=None, rawData=None, cntArr=None, instr_id=None, instr_location=None):
        """
        Update meta data

        :param data: Data group in h5
        :param rawData: Raw data array
        :param cntArr: Scan/subaperture count array
        :param instr_id: Instrument id
        :param instr_location: Instrument physical location
        :return:
        """
        self.h5f = h5py.File(self.filePath, self.otype)
        self.entry = self.h5f[self.entryName]
        if instr_id:
            self.entry['Instrument'].attrs[u'instr_id'] = instr_id
        if instr_location:
            self.entry['Instrument'].attrs[u'instr_location'] = instr_location
        if data:
            self.entry['Instrument/resolution'][...] = data.attrs[u'data_step']
            self.entry['Instrument/pupil_data_dimensions'][...] = 1
        if np.any(rawData):
            self.entry['Measurement/type'][...] = rawData['rotation'] + ',' + rawData['scan_mode'] + ',' + rawData[
                'scan_type']
            self.entry['Measurement/Alignment/X'][...] = float(rawData['center'])
            self.entry['Measurement/Alignment/scan_length'][...] = float(rawData['length'])
            self.entry['Measurement/Alignment/prescan_length'][...] = float(rawData['prescan'])
            self.entry['Measurement/Alignment/signal_threshold'][...] = float(rawData['treshold'])
            self.entry['Measurement/Alignment/nb_images_avg'][...] = int(rawData['average'])
            self.entry['Measurement/Alignment/motionSpeed'][...] = float(rawData['scan_vel'])
            self.entry['Measurement/Alignment/exposure_time'][...] = float(rawData['integration_time'])
            self.entry['Sample/orientation'][...] = rawData['orientation']
            self.entry['Sample/support_type'][...] = rawData['support_type']
            self.entry['Sample/support_distance'][...] = float(rawData['support_distance'])
        if cntArr:
            self.entry['Measurement/scan_count'][...] = cntArr[0]
            self.entry['Measurement/subaperture_count'][...] = cntArr[1]

        self.h5f.close()

    def metaData(self):
        """
        Meta data such as measurement conditions, sample details etc...

        :return:
        """
        h5instr = self.entry.create_group('Instrument')
        h5instr.attrs[u'NX_class'] = u'NXinstrument'
        h5instr.attrs[u'wavelength'] = u''
        h5instr.attrs[u'conditions'] = 'placed within an enclosure'
        h5instr['name'] = 'LTP @ ESRF'
        h5instr['version'] = 'v1.0.1'
        h5instr['pupil_dimensions'] = [1.0]  # mm
        h5instr['pupil_dimensions'].attrs[u'units'] = u'mm'
        h5instr['pupil_dimensions'].attrs[u'description'] = u'size of useful pupil'
        h5instr['pupil_data_dimensions'] = [1]  # no of pixels
        h5instr['pupil_data_dimensions'].attrs[u'description'] = u'number of (useful) data points in a single image'
        h5instr['resolution'] = [1.0]  # mm
        h5instr['resolution'].attrs[u'units'] = u'mm'
        h5instr['scale_factor'] = 1
        h5instr['scale_factor'].attrs[u'units'] = u'urad'
        h5instr['scale_factor'].attrs[
            u'description'] = u'after multiplying this scale factor to the final mirror data (slopes), we will get data in described units'
        h5instr['coordinate_system'] = str({u'X': 1, u'Y': 1, u'Ry': 1})
        h5instr['coordinate_system'].attrs[
            'info'] = '+ve if instr coordinates (motor positions) increase from start to end \n and 1 if no scaling '

        h5msr = self.entry.create_group('Measurement')
        h5msr.attrs[u'NX_class'] = u'NXmeasurement'
        h5msr['scan_count'] = 0
        h5msr['scan_count'].attrs[u'description'] = u'number of scans'
        h5msr['subaperture_count'] = 1
        h5msr['temperature'] = []

        h5msr['detector_to_instr_coord'] = str({u'X': 1, u'Y': 1, u'Ry': 1})
        h5msr['instr_to_sample_coord'] = str({u'X': 1, u'Y': 1, u'Ry': 1})

        h5msr['type'] = u'AB, Scan On Fly'

        aln_center = h5msr.create_group("Alignment")
        aln_center.attrs[u'name'] = u'Motor values during aligment'
        aln_center['X'] = 0
        aln_center['X'].attrs[u'units'] = u'mm'
        aln_center['Y'] = 0
        aln_center['Y'].attrs[u'units'] = u'mm'
        aln_center['RY'] = 0
        aln_center['RY'].attrs[u'units'] = u'deg'
        aln_center['motionSpeed'] = [25]
        aln_center['motionSpeed'].attrs[u'units'] = u'mm/s'
        aln_center['motionSpeed'].attrs[u'axes'] = u'[X]'
        aln_center['scan_length'] = 0
        aln_center['scan_length'].attrs[u'units'] = u'mm'
        aln_center['prescan_length'] = 0
        aln_center['prescan_length'].attrs[u'units'] = u'mm'
        aln_center['exposure_time'] = 0
        aln_center['exposure_time'].attrs[u'units'] = u'ms'
        aln_center['nb_images_avg'] = 1
        aln_center['signal_threshold'] = 0
        aln_center['signal_threshold'].attrs[u'units'] = u''

        h5sample = self.entry.create_group('Sample')
        h5sample.attrs[u'NX_class'] = u'NXsample'
        h5sample['name'] = ''
        h5sample['no_of_regions'] = 1
        h5sample['shape'] = 'plane'  # for multiple regions, an array sequence
        h5sample['material'] = 'uncoated'
        h5sample['material_bulk'] = 'Si'
        h5sample['total_dimensions'] = []
        h5sample['total_dimensions'].attrs[u'units'] = u'mm'
        h5sample['total_dimensions'].attrs[u'format'] = u'[length, width, height]'
        h5sample['total_dimensions'].attrs[u'description'] = u'length along X-ray beam path direction'
        h5sample['regions_of_interest'] = []
        h5sample['regions_of_interest'].attrs[u'units'] = u'mm'
        h5sample['regions_of_interest'].attrs[u'format'] = u'[[X1,X2,Y1,Y2],...]'
        h5sample['orientation'] = 'up/side/down'
        h5sample['support_type'] = 'cylinders/spheres'
        h5sample['support_distance'] = 0
        h5sample['comments'] = '\n mirror placed on cyl rods at pos X=-L/4 & X=L/4 from center, no bender...'
        h5sample['params'] = 'Rc/p-q-theta/Major-minor'
        h5sample['params'].attrs[u'units'] = u'm/m-m-mrad/m-m'

        # h5users                                                     = self.h5f['Users'] if 'Users' in self.h5f else self.h5f.create_group('Users')
        # h5users.attrs[u'NX_class']                                  = u'NXuser'
        # if 'Mercury' not in h5users:
        #     h5u                                                     = h5users.create_group('Mercury')
        #     h5u.attrs[u'NX_class']                                  = u'NXuser'
        #     h5u['full_name']                                        = 'Mercury'
        #     h5u['email']                                            = ''
        #     h5u['location']                                         = ''
        #
        # self.entry['User']                                          = h5users['Mercury']

        h5u = self.entry.create_group('User')
        h5u.attrs[u'NX_class'] = u'NXuser'
        h5u['full_name'] = 'user_name'
        h5u['email'] = ''
        h5u['location'] = ''
